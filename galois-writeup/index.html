<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>lily's blog</title>
    <link rel="stylesheet" type="text/css" href="/assets/custom.css" />
    <link rel="stylesheet" type="text/css" href="/assets/syntax.css">
    <link rel="icon" href="/images/logo.gif" type="image/gif">
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    <a rel="me" href="https://hachyderm.io/@rctcwyvrn"></a>
</head>

<body>
    <script src="/cat/oneko.js"></script>
    <div id="header">
        <div id="logo">
            <a href="/">
                <img src="/images/logo.gif" width="34" height="24" align="top">
                lily's blog</a>
        </div>
        <div id="navigation">
            <a href="/">Home</a>
            <a href="https://github.com/rctcwyvrn">Github</a>
            <a href="/info/about/">About</a>
            <a href="/info/contact/">Contact</a>
            <a href="/archive/">Archive</a>
        </div>
    </div>

    <div id="content">
        <h1>
UTCTF Galois. Remember kids, never repeat a nonce!
</h1>

        
<div class="info">
    <p> Posted on 2020-03-12
        
        by [rctcwyvrn]
        
    </p>
    <p>
        
        Team: <a href="https://ubcctf.github.io/ ">Maple Bacon, University of British Columbia</a>
        
    </p>
</div>
<p>Code can be found <a href="https://github.com/rctcwyvrn/ctf_stuff/tree/master/utctf/galois">here</a></p>
<p>As you probably read in the title, this is a writeup about a crypto challenge involving nonce repeition. Namely an AES-GCM challenge, where we are given an encrypted ciphertext and a encryption/decrpytion oracle, but no tag to go along with our ciphertext.</p>
<h2 id="gcm-mode">GCM Mode</h2>
<p>What is GCM mode? Well as I learned last weekend, GCM (Galois counting mode) mode is a cool little cipher mode that generates 2 things at once using your symmetric cipher</p>
<ol>
<li>A ciphertext</li>
<li>A tag which can be used to verify both identity and integrity</li>
</ol>
<p>The ciphertext is fairly straightforward, it's just the ciphertext that you would get from CTR mode, namely the plaintext XOR the keystream generated by encrypting a counter.</p>
<p>The tag is a bit more complex, it's generated using the ciphertext and the encryption key as follows. (I'm going to ignore the auth-data, but it just adds more clutter and not much elses)</p>
<p>Consider a ciphertext C 10 bytes long.</p>
<ol>
<li>Calculate the length v = bitlen(last block of C, split into 8 byte blocks), so in our case the last block is 2 bytes so the bitlen is 16</li>
<li>Calculate the following polynomial under GF(2^128), the Galois field with 128 elements. I'll explain in a bit more detail what that means later.<br />
\[ f(x) = C_1x^3 + C_2x^2 + vx + E_k(nonce)\]
Where C_1 and C_2 are the two ciphertext blocks, with C_2 padded to 8 bytes and E_k represents encryption using the cipher and key</li>
<li>The tag T is then just f(H), where H is the encryption key and H = E_k(A string of 128 0's)</li>
</ol>
<p>So how does one evaluate things in GF(2^128)? I have no fucking clue. Just kidding I know a little bit.</p>
<h2 id="galois-fields">Galois fields</h2>
<p>A Galois field or finite field is just that, a field (a set with addition and multiplication operators) with a finite number of elements. I honestly don't have the math chops to really give a good explanation, but what I do understand is that addition under this field is XOR, which will be important for the attack. Google a 3b1b video or smth. I might update this after I take my algerbra course next year.</p>
<h2 id="the-attack">The attack</h2>
<p>So one look at the code and you'll see that the nonce and key are generated at the same time, and never changed. The attack we want to employ is nicknamed <code>The forbidden attack</code>, probably because if you mess up your crypto this badly you deserve to be banished into the shadow realm.</p>
<p>Here's the attack in a nutshell. Assume we've sent and collected 8 byte ciphertexts C_a and C_b and their corresponding tags T_a and T_b.<br />
Our tags will be generated using
\[ f(x) = C_ax^2 + v_ax + E_k(nonce)\]
So
\[ T_a = f(H) = C_{a}H^2 + v_aH + E_k(nonce)\]
Unfortunately, we don't know what H is, but what we can do is search for roots of this polynomial, so lets modify f. Let
\[ f'(x) = C_ax^2 + v_ax + E_k(nonce) + T_a\]
So now the root of f' will be our encryption key
\[ f'(H) = C_aH^2 + v_aH + E_k(nonce) + T_a = T_a + T_a = 0\]
Note: Why does T_a + T_a = 0, because (+) in the field is XOR as mentioned earlier</p>
<p>The problem is that we don't know all of f', namely we don't know what E_k(nonce) is. If only it was constant and there was some way of elimiating it...<br />
Let
\[ g'(x) = C_bx^2 + v_bx + E_k(nonce) + T_b\]
\[ h(x) = g'(x) + f'(x)\]
\[ h(x) = (C_a + C_b)x^2 + v_ax + v_bx + E_k(nonce) + E_k(nonce) + T_a + T_b\]
\[ h(x) = (C_a + C_b)x^2 + (v_a + v_b)x + T_a + T_b\]</p>
<p>Well that was easy! So the attack is then very straightforward</p>
<ol>
<li>Collect pairs of ciphertexts and their tags encrypted under the same nonce</li>
<li>Generate h(x) for each pair and find the root(s)</li>
<li>Decide that the root that appeared the most times must be the correct value of H</li>
</ol>
<p>So now what do we do with the hash_key H? What we would love to do is generate a tag for the flag, but looking at the tag equation
\[ T_{flag} = f_{flag}(H) = C_{flag}H^2 + v_{flag}H + E_k(nonce)\]</p>
<p>We still don't know the value of the encrypted nonce. Now if only that nonce was constant and there was some way of eliminating it...</p>
<p>Let g be the tag function for a known ciphertext/tag pair<br />
\[ g(x) + f_{flag}(x) = (C_a + C_{flag})x^2 + (v_a + v_{flag})x\]
\[ g(H) + f_{flag}(H) = (C_a + C_{flag})H^2 + (v_a + v_{flag})H\]
\[ T_{flag} = (C_a + C_{flag})H^2 + (v_a + v_{flag})H - T_a\]</p>
<p>Well that was also easy wasn't it.</p>
<p><code>utflag{6cm_f0rb1dd3n_4774ck_777}</code></p>
<p>Note: I used <code>nonce-disrespect</code>'s recover and forge to actually recover H and generate the tag for the flag. <a href="https://github.com/nonce-disrespect/nonce-disrespect">Source</a></p>
<p>Other resources:</p>
<ul>
<li><a href="https://eprint.iacr.org/2016/475.pdf">Paper</a></li>
<li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Devlin-Nonce-Disrespecting-Adversaries-Practical-Forgery-Attacks-On-GCM-In-TLS.pdf">Nonce disrespect presentation</a></li>
</ul>


    </div>
</body>

</html>