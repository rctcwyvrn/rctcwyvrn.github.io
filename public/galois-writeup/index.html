<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>rctcwyvrn's blog - $title$</title>
    <link rel="stylesheet" type="text/css" href="/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="/css/syntax.css">
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
</head>

<body>
    <div id="header">
        <div id="logo">
            <a href="/">
                <img src="/images/logo.gif" width="34" height="24" align="top">
                rctcwyvrn's blog</a>
        </div>
        <div id="navigation">
            <a href="/">Home</a>
            <a href="https://github.com/rctcwyvrn">Github</a>
            <a href="/info/about.html">About</a>
            <a href="/info/contact.html">Contact</a>
            <a href="/archive.html">Archive</a>
        </div>
    </div>

    <div id="content">
        <h1>
UTCTF Galois. Remember kids, never repeat a nonce!
</h1>

        
&lt;p&gt;Code can be found &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rctcwyvrn&#x2F;ctf_stuff&#x2F;tree&#x2F;master&#x2F;utctf&#x2F;galois&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;As you probably read in the title, this is a writeup about a crypto challenge involving nonce repeition. Namely an AES-GCM challenge, where we are given an encrypted ciphertext and a encryption&#x2F;decrpytion oracle, but no tag to go along with our ciphertext.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gcm-mode&quot;&gt;GCM Mode&lt;&#x2F;h2&gt;
&lt;p&gt;What is GCM mode? Well as I learned last weekend, GCM (Galois counting mode) mode is a cool little cipher mode that generates 2 things at once using your symmetric cipher&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A ciphertext&lt;&#x2F;li&gt;
&lt;li&gt;A tag which can be used to verify both identity and integrity&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The ciphertext is fairly straightforward, it&#x27;s just the ciphertext that you would get from CTR mode, namely the plaintext XOR the keystream generated by encrypting a counter.&lt;&#x2F;p&gt;
&lt;p&gt;The tag is a bit more complex, it&#x27;s generated using the ciphertext and the encryption key as follows. (I&#x27;m going to ignore the auth-data, but it just adds more clutter and not much elses)&lt;&#x2F;p&gt;
&lt;p&gt;Consider a ciphertext C 10 bytes long.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Calculate the length v = bitlen(last block of C, split into 8 byte blocks), so in our case the last block is 2 bytes so the bitlen is 16&lt;&#x2F;li&gt;
&lt;li&gt;Calculate the following polynomial under GF(2^128), the Galois field with 128 elements. I&#x27;ll explain in a bit more detail what that means later.&lt;br &#x2F;&gt;
\[ f(x) = C_1x^3 + C_2x^2 + vx + E_k(nonce)\]
Where C_1 and C_2 are the two ciphertext blocks, with C_2 padded to 8 bytes and E_k represents encryption using the cipher and key&lt;&#x2F;li&gt;
&lt;li&gt;The tag T is then just f(H), where H is the encryption key and H = E_k(A string of 128 0&#x27;s)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So how does one evaluate things in GF(2^128)? I have no fucking clue. Just kidding I know a little bit.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;galois-fields&quot;&gt;Galois fields&lt;&#x2F;h2&gt;
&lt;p&gt;A Galois field or finite field is just that, a field (a set with addition and multiplication operators) with a finite number of elements. I honestly don&#x27;t have the math chops to really give a good explanation, but what I do understand is that addition under this field is XOR, which will be important for the attack. Google a 3b1b video or smth. I might update this after I take my algerbra course next year.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-attack&quot;&gt;The attack&lt;&#x2F;h2&gt;
&lt;p&gt;So one look at the code and you&#x27;ll see that the nonce and key are generated at the same time, and never changed. The attack we want to employ is nicknamed &lt;code&gt;The forbidden attack&lt;&#x2F;code&gt;, probably because if you mess up your crypto this badly you deserve to be banished into the shadow realm.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the attack in a nutshell. Assume we&#x27;ve sent and collected 8 byte ciphertexts C_a and C_b and their corresponding tags T_a and T_b.&lt;br &#x2F;&gt;
Our tags will be generated using
\[ f(x) = C_ax^2 + v_ax + E_k(nonce)\]
So
\[ T_a = f(H) = C_{a}H^2 + v_aH + E_k(nonce)\]
Unfortunately, we don&#x27;t know what H is, but what we can do is search for roots of this polynomial, so lets modify f. Let
\[ f&#x27;(x) = C_ax^2 + v_ax + E_k(nonce) + T_a\]
So now the root of f&#x27; will be our encryption key
\[ f&#x27;(H) = C_aH^2 + v_aH + E_k(nonce) + T_a = T_a + T_a = 0\]
Note: Why does T_a + T_a = 0, because (+) in the field is XOR as mentioned earlier&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that we don&#x27;t know all of f&#x27;, namely we don&#x27;t know what E_k(nonce) is. If only it was constant and there was some way of elimiating it...&lt;br &#x2F;&gt;
Let
\[ g&#x27;(x) = C_bx^2 + v_bx + E_k(nonce) + T_b\]
\[ h(x) = g&#x27;(x) + f&#x27;(x)\]
\[ h(x) = (C_a + C_b)x^2 + v_ax + v_bx + E_k(nonce) + E_k(nonce) + T_a + T_b\]
\[ h(x) = (C_a + C_b)x^2 + (v_a + v_b)x + T_a + T_b\]&lt;&#x2F;p&gt;
&lt;p&gt;Well that was easy! So the attack is then very straightforward&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Collect pairs of ciphertexts and their tags encrypted under the same nonce&lt;&#x2F;li&gt;
&lt;li&gt;Generate h(x) for each pair and find the root(s)&lt;&#x2F;li&gt;
&lt;li&gt;Decide that the root that appeared the most times must be the correct value of H&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;So now what do we do with the hash_key H? What we would love to do is generate a tag for the flag, but looking at the tag equation
\[ T_{flag} = f_{flag}(H) = C_{flag}H^2 + v_{flag}H + E_k(nonce)\]&lt;&#x2F;p&gt;
&lt;p&gt;We still don&#x27;t know the value of the encrypted nonce. Now if only that nonce was constant and there was some way of eliminating it...&lt;&#x2F;p&gt;
&lt;p&gt;Let g be the tag function for a known ciphertext&#x2F;tag pair&lt;br &#x2F;&gt;
\[ g(x) + f_{flag}(x) = (C_a + C_{flag})x^2 + (v_a + v_{flag})x\]
\[ g(H) + f_{flag}(H) = (C_a + C_{flag})H^2 + (v_a + v_{flag})H\]
\[ T_{flag} = (C_a + C_{flag})H^2 + (v_a + v_{flag})H - T_a\]&lt;&#x2F;p&gt;
&lt;p&gt;Well that was also easy wasn&#x27;t it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;utflag{6cm_f0rb1dd3n_4774ck_777}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Note: I used &lt;code&gt;nonce-disrespect&lt;&#x2F;code&gt;&#x27;s recover and forge to actually recover H and generate the tag for the flag. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nonce-disrespect&#x2F;nonce-disrespect&quot;&gt;Source&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Other resources:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;eprint.iacr.org&#x2F;2016&#x2F;475.pdf&quot;&gt;Paper&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.blackhat.com&#x2F;docs&#x2F;us-16&#x2F;materials&#x2F;us-16-Devlin-Nonce-Disrespecting-Adversaries-Practical-Forgery-Attacks-On-GCM-In-TLS.pdf&quot;&gt;Nonce disrespect presentation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;


    </div>
</body>

</html>